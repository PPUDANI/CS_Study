/*
 * >> C#의 컴파일 과정 요약
 *   - C# 컴파일러에 의해 IL 코드로 작성된 실행파일을 만듦.
 *   - CLR, Mono Runtine으로 하드웨어와 운영체제에 따라 적합한 컴파일을 진행함.
 *   - 동적 컴파일 JIT 방식과 정적 컴파일인 AOT 방식이 있음.
 *   - 실행 환경이 일정한 콘솔, 모바일 플랫폼에서는 AOT 방식을 사용함.
 *   - PC나 고성능 플랫폼에는 효율을 극대화 하기 위해 JIT 방식이 사용됨.
 *   
 *   
 * >> CLR(Common Language Runtime)이란?
 *   - C#으로 만든 프로그램은 CLR 위에서 실행됨.
 *   - Java의 가상머신과 비슷한 개념으로 CLR은 .NET FrameWork와 함께 OS 위에 설치되며, .NET 프로그램의 실행 환경을 관리함.
 *   - CLR은 Windows환경에서 .NET 애플리케이션을 실행하기위한 런타임임.
 *   
 *   
 * >> Mono Runtime
 *   - Mono는 Microsoft의 자회사에 의해 개발된 오픈소스임.
 *   - Windows, macOS, Linux, iOS, Android 등 여러 플랫폼에서 NET 애플리케이션을 실행할 수 있게 해주는 런타임임.
 *   - 특히 모바일 플랫폼(IOS, Android)과 Unity에서 사용됨. (Unity 엔진은 CLR 대산 Mono를 사용함.)
 * 
 *
 * >> 적시 컴파일(Just In Time, JIT)이란?
 *   - 적시 컴파일은 런타임 중에 IL 코드(Java는 바이트코드)를 네이티브 코드로 변환하는 동적 컴파일 방식임.
 *   - JIT는 매서드 단위로 컴파일하는데 최적화를 위해 자주 호출되는 코드를 핫 스팟(Hot Spot)으로 분류함.
 *   - 분류된 코드는 여러 기법에 의해 최적화하고(매서드 인라이닝, 루프 언 롤링) 네이티브 코드로 변환해서 메모리에 올림.
 *   
 *     1. 매서드 인라이닝(Method Inlining) : 함수 코드 호출한 지점에 직접 붙여서 코드로 만듦.(C++의 inline과 비슷)
 *     2. 루프 언롤링(Loop Unrolling) : 반복문 내부 코드를 반복한 수 만큼 코드를 늘림.
 *     
 *       ///////////////////////////////////
 *       //                               //
 *       //  for (int i = 0; i < 5; i++)  //
 *       //  {                            //
 *       //      sum += 1;                //
 *       //  }                            //
 *       //                               //
 *       ///////////////////////////////////
 *       
 *         위 반복문 코드를 아래처럼 수정함.
 *       
 *       ///////////////////////////////////
 *       //                               //
 *       //  sum += 1;                    //
 *       //  sum += 1;                    //
 *       //  sum += 1;                    //
 *       //  sum += 1;                    //
 *       //  sum += 1;                    //
 *       //                               //
 *       ///////////////////////////////////
 *       
 *       장점 : 루프의 오버헤드를 줄일 수 있음.
 *       단점 : 코드 크기가 증가함.
 *       
 *   - 자주 실행되는 메서드만 네이티브 코드로 변환하여 메모리에 올림으로써 메모리 사용량을 줄이고, CPU 캐시 적중률을 높일 수 있음.
 *   - 변환된 네이티브 코드는 메모리에 누적되어 저장되며, 이후 호출 시 재사용됨. 
 *   - 반면 호출되지 않은 코드들은 실행 중에 필요할 때 동적으로 컴파일되므로, 첫 호출 시 성능 저하가 발생할 수 있음.
 *   - JIT 컴파일은 실행 중에 코드를 최적화하고, 동적으로 컴파일하여 성능을 향상시키는 방식임.
 *   - 다양한 하드웨어 환경에서 실행 중에 최적화가 이루어져 성능을 극대화할 수 있기 때문에 PC나 고성능 플랫폼에 적합한 컴파일 방식임.
 *   
 *    
 * >> AOT(Ahead-of-Time)컴파일
 *   - AOT 컴파일은 애플리케이션이 실행되기 전에 코드가 네이티브 코드로 미리 컴파일되는 정적 컴파일 방식임.
 *   - JIT 처럼 환경에 따라 동적으로 최적화를 하지 못해 
 *   - 정책상 JIT 컴파일을 할 수 없는 경우(IOS..) 미리 컴파일해야함.
 *   - 메모리와 CPU 자원이 제한적이고, 게임의 실행 환경이 일정한 콘솔과 모바일 플랫폼에 적합한 컴파일 방식임.
 *   
 *   
 */
